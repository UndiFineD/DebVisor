# DebVisor Web Panel - Input Validation & Output Escaping Guide\n\nThis document provides comprehensive guidance on input validation, output escaping, and XSS prevention for the DebVisor web panel.\n\n## Table of Contents\n\n1. Overview\n\n1. Input Validation Strategy\n\n1. Output Escaping & XSS Prevention\n\n1. Validation Patterns\n\n1. Context-Specific Escaping\n\n1. Common Vulnerabilities\n\n1. Implementation Checklist\n\n## Overview\n\n### The Problem\n\nWeb applications receive user input from many sources:\n\n- Form submissions\n\n- URL parameters\n\n- API requests\n\n- Cookies\n\n- Headers\n\n### Malicious input can cause\n\n- **SQL Injection**: Execute arbitrary database queries\n\n- **Command Injection**: Execute arbitrary system commands\n\n- **Cross-Site Scripting (XSS)**: Execute arbitrary JavaScript in other users' browsers\n\n- **Path Traversal**: Access files outside intended directory\n\n- **Buffer Overflow**: Crash application or execute code\n\n### The Solution\n\n### Defense in Depth\n\n1.**Input Validation**: Accept only known-good data\n1.**Output Escaping**: Render data safely for each context\n1.**Security Headers**: Control what browsers can do\n1.**Content Security Policy**: Restrict script execution\n\n## Input Validation Strategy\n\n### Whitelist vs Blacklist\n\n- *? Don't use blacklist**(block specific bad things):\n\n## BAD: Try to block specific dangerous characters\n\n    def is_safe(input_str):\n        dangerous = ['', '"', "'", ';', '--']\n        for char in dangerous:\n            if char in input_str:\n                return False\n        return True\n\n## Attacker bypasses: <%65%6E%63%6F%64%65%64 attacks\n\n- *? Use whitelist**(accept only known-good things):\n\n## GOOD: Accept only RFC-compliant hostnames\n\n    def validate_hostname(hostname):\n        if not hostname or len(hostname) > 253:\n            return False\n\n## RFC 1123: labels are 1-63 chars, alphanumeric and hyphen\n\n        pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$'\n        return bool(re.match(pattern, hostname))\n\n## Only: "node-01", "node.01" pass; "" fails\n\n## Validation Levels\n\n### Level 1: Type Checking\n\n## Validate input type\n\n    def level1_type_check(value, expected_type):\n        """Reject wrong types"""\n        if not isinstance(value, expected_type):\n            raise ValidationError(f'Expected {expected_type.**name**}')\n        return value\n\n## Usage\n\n    pool_name = request.form.get('pool')\n    pool_name = level1_type_check(pool_name, str)  # Ensure string\n\n## Level 2: Format Validation\n\n    import re\n    def level2_format_check(value, pattern):\n        """Validate against regex pattern"""\n        if not re.match(pattern, value):\n            raise ValidationError('Invalid format')\n        return value\n\n## Usage [2]\n\n    hostname = request.form.get('hostname')\n    hostname = level2_format_check(hostname, r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$')\n\n## Level 3: Length Validation\n\n    def level3_length_check(value, min_len=1, max_len=1000):\n        """Validate string length"""\n        if len(value)  max_len:\n            raise ValidationError(f'Length must be {min_len}-{max_len}')\n        return value\n\n## Usage [3]\n\n    hostname = level3_length_check(hostname, min_len=1, max_len=253)\n\n## Level 4: Range Validation\n\n    def level4_range_check(value, min_val=None, max_val=None):\n        """Validate numeric range"""\n        value = int(value)\n        if min_val is not None and value < min_val:\n            raise ValidationError(f'Value must be >= {min_val}')\n        if max_val is not None and value > max_val:\n            raise ValidationError(f'Value must be <= {max_val}')\n        return value\n\n## Usage [4]\n\n    port = level4_range_check(request.form.get('port'), min_val=1024, max_val=65535)\n\n## Level 5: Business Logic Validation\n\n    def level5_business_logic(hostname, user_role):\n        """Validate against business rules"""\n\n## User can only modify nodes in their environment\n\n        node = Node.query.filter_by(hostname=hostname).first()\n        if not node:\n            raise ValidationError('Node not found')\n        if user_role == 'developer' and node.environment == 'production':\n            raise ValidationError('Developers cannot modify production nodes')\n        return node\n\n## Usage [5]\n\n    node = level5_business_logic(hostname, current_user.role)\n\n## Output Escaping & XSS Prevention\n\n### Context Matters\n\n### Same data, different contexts\n\n    {{ user_name }}\n      var name = "{{ user_name }}";\n      .user { color: {{ user_color }}; }\n    Search\nEach context requires**different escaping**.\n\n### HTML Escaping\n\n    from markupsafe import escape\n\n## HTML escaping converts special chars to entities\n\n    def html_escape(text):\n        """Escape for HTML content context"""\n        return escape(text)\n\n## Example\n\n    user_input = 'alert("XSS")'\n    escaped = html_escape(user_input)\n\n## Result: &lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt\n\n## In Jinja2 templates (automatic)\n\n    {% raw %}\n    Welcome {{ username }}\n    {% endraw %}\n\n## HTML Attribute Escaping\n\n    def html_attr_escape(text):\n        """Escape for HTML attribute context"""\n        text = escape(text)\n\n## Additional escaping for attributes\n\n        text = text.replace('"', '&quot;')\n        text = text.replace("'", '&#x27;')\n        return text\n\n## Example [2]\n\n    user_input = 'test" onload="alert(1)'\n    escaped = html_attr_escape(user_input)\n\n## Result: test&quot; onload=&quot;alert(1)\n\n## In template attribute\n\n    {% raw %}\n    {% endraw %}\n\n## JavaScript String Escaping\n\n    import json\n    def js_string_escape(text):\n        """Escape for JavaScript string literal context"""\n\n## Use json.dumps which handles all escaping\n\n        return json.dumps(text)\n\n## Example [3]\n\n    user_input = 'test"; alert("XSS'\n    escaped = js_string_escape(user_input)\n\n## Result: "test\"; alert(\"XSS"\n\n## Usage in template\n\n    {% raw %}\n      var username = {{ username | tojson }};\n    {% endraw %}\n\n## CSS Escaping\n\n    import re\n    def css_escape(text):\n        """Escape for CSS context"""\n\n## Remove all special CSS characters\n\n## CSS identifiers: alphanumeric, hyphen, underscore, non-ASCII, escaped chars\n\n## For safety, only allow safe subset\n\n        safe_chars = re.sub(r'[^a-zA-Z0-9_-]', '', text)\n        return safe_chars\n\n## Example [4]\n\n    user_input = 'red; background: url(javascript:alert(1))'\n    escaped = css_escape(user_input)\n\n## Result: red-backgroundurljava?scriptalert1\n\n## For colors specifically\n\n    def css_color_escape(color):\n        """Validate and escape CSS color"""\n\n## Only allow hex colors #RRGGBB or named colors\n\n        if re.match(r'^#[0-9a-fA-F]{6}$', color):\n            return color\n        if color in ['red', 'blue', 'green', 'black', 'white']:\n            return color\n        raise ValueError('Invalid color')\n\n## URL Escaping\n\n    from urllib.parse import quote\n    def url_param_escape(text):\n        """Escape for URL parameter context"""\n\n## URL encode special characters\n\n        return quote(text, safe='')\n\n## Example [5]\n\n    user_input = 'hello world&param=value'\n    escaped = url_param_escape(user_input)\n\n## Result: hello%20world%26param%3Dvalue\n\n## In template\n\n    {% raw %}\n    Search\n    {% endraw %}\n\n## Validation Patterns\n\n### Common Data Types\n\n    import re\n    from ipaddress import IPv4Address, IPv6Address, ip_address\n    class Validators:\n        """Reusable validation patterns"""\n\n## Network identifiers\n\n        @staticmethod\n        def validate_hostname(value):\n            """RFC 1123 hostname"""\n            pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid hostname')\n            if len(value) > 253:\n                raise ValueError('Hostname too long')\n            return value\n        @staticmethod\n        def validate_ipv4(value):\n            """IPv4 address"""\n            try:\n                ip = IPv4Address(value)\n                return str(ip)\n            except Exception:\n                raise ValueError('Invalid IPv4 address')\n        @staticmethod\n        def validate_ipv6(value):\n            """IPv6 address"""\n            try:\n                ip = IPv6Address(value)\n                return str(ip)\n            except Exception:\n                raise ValueError('Invalid IPv6 address')\n        @staticmethod\n        def validate_mac_address(value):\n            """MAC address (XX:XX:XX:XX:XX:XX or XX-XX-XX-XX-XX-XX)"""\n            pattern = r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid MAC address')\n            return value.upper()\n        @staticmethod\n        def validate_port(value):\n            """TCP/UDP port (1-65535)"""\n            port = int(value)\n            if port  65535:\n                raise ValueError('Port out of range (1-65535)')\n            return port\n\n## Identifiers\n\n        @staticmethod\n        def validate_uuid(value):\n            """UUID (RFC 4122)"""\n            pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'\n            if not re.match(pattern, value, re.IGNORECASE):\n                raise ValueError('Invalid UUID')\n            return value.lower()\n        @staticmethod\n        def validate_pool_name(value):\n            """Storage pool name"""\n            pattern = r'^[a-zA-Z0-9][a-zA-Z0-9_-]{0,30}[a-zA-Z0-9]$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid pool name (alphanumeric, hyphen, underscore only)')\n            return value\n        @staticmethod\n        def validate_snapshot_name(value):\n            """Snapshot name"""\n            pattern = r'^[a-zA-Z0-9][a-zA-Z0-9_-]{0,62}[a-zA-Z0-9]$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid snapshot name')\n            return value\n        @staticmethod\n        def validate_vm_name(value):\n            """Virtual machine name"""\n            pattern = r'^[a-zA-Z0-9][a-zA-Z0-9._-]{0,63}[a-zA-Z0-9]$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid VM name')\n            return value\n\n## Email and text\n\n        @staticmethod\n        def validate_email(value):\n            """Email address (simplified)"""\n            pattern = r'^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid email address')\n            return value.lower()\n        @staticmethod\n        def validate_username(value):\n            """Linux username (3-32 chars)"""\n            pattern = r'^[a-z_][a-z0-9_-]{2,31}$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid username (3-32 alphanumeric, underscore, hyphen)')\n            return value\n        @staticmethod\n        def validate_url(value):\n            """HTTP/HTTPS URL"""\n            pattern = r'^https?://[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(/[a-zA-Z0-9._~:/?#[\]@!$&\'()*+,;=-]*)?$'\n            if not re.match(pattern, value):\n                raise ValueError('Invalid URL')\n            if len(value) > 2048:\n                raise ValueError('URL too long')\n            return value\n        @staticmethod\n        def validate_cidr(value):\n            """CIDR notation (192.168.1.0/24)"""\n            try:\n                from ipaddress import ip_network\n                net = ip_network(value, strict=False)\n                return str(net)\n            except Exception:\n                raise ValueError('Invalid CIDR notation')\n\n## Usage [6]\n\n    @app.route('/api/nodes', methods=['POST'])\n    @login_required\n    def create_node():\n        """Create node with validated input"""\n        try:\n            hostname = Validators.validate_hostname(request.form.get('hostname', ''))\n            mgmt_ip = Validators.validate_ipv4(request.form.get('mgmt_ip', ''))\n            mac_addr = Validators.validate_mac_address(request.form.get('mac', ''))\n\n## RPC call\n\n            result = rpc_client.create_node(hostname, mgmt_ip, mac_addr)\n            audit_log('AUDIT', f'Created node {hostname}')\n            return jsonify(result)\n        except ValueError as e:\n            return jsonify({'error': str(e)}), 400\n\n## Context-Specific Escaping\n\n### Complete Flask Application with Escaping\n\n    from flask import Flask, render_template, request, jsonify, escape\n    from markupsafe import Markup\n    import html\n    import json\n    app = Flask(**name**)\n\n## Context 1: HTML Template (automatic)\n\n    @app.route('/node/')\n    def node_detail(node_id):\n        """Node detail page with automatic HTML escaping"""\n        node = rpc_client.get_node_info(node_id)\n\n## Jinja2 automatically escapes {{ node.hostname }}\n\n        return render_template('node.html', node=node)\n\n## HTML template\n\n    """\n    Node: {{ node.hostname }}\n    Status: {{ node.status }}\n    Description: {{ node.description }}\n    """\n\n## Context 2: HTML Attribute\n\n    @app.route('/search')\n    def search():\n        """Search with user input in attribute"""\n        query = request.args.get('q', '')\n\n## Use urlencode for URL parameters\n\n        return render_template('search.html', query=query)\n\n## HTML template [2]\n\n    """\n        Search\n    """\n\n## Context 3: JavaScript\n\n    @app.route('/api/dashboard')\n    def dashboard_api():\n        """Return dashboard data as JSON (safe for JS context)"""\n        user_data = {\n            'username': current_user.username,\n            'role': current_user.role,\n            'node_count': len(rpc_client.list_nodes()),\n        }\n        return jsonify(user_data)\n\n## JavaScript\n\n    """\n    fetch('/api/dashboard')\n        .then(r => r.json())\n        .then(data => {\n            document.getElementById('username').textContent = data.username;\n        });\n    """\n\n## Context 4: CSV Export (special escaping)\n\n    @app.route('/export/nodes.csv')\n    @login_required\n    def export_nodes_csv():\n        """Export nodes as CSV"""\n        nodes = rpc_client.list_nodes()\n        csv_lines = ['hostname,ip,status,description']\n        for node in nodes:\n\n## CSV escaping: quotes and newlines\n\n            def csv_escape(value):\n                if '"' in value or ',' in value or '\n' in value:\n                    return f'"{value.replace('"', '""')}"'\n                return value\n            line = ','.join([\n                csv_escape(node.hostname),\n                csv_escape(node.ip),\n                csv_escape(node.status),\n                csv_escape(node.description),\n            ])\n            csv_lines.append(line)\n        response = app.make_response('\n'.join(csv_lines))\n        response.headers['Content-Type'] = 'text/csv'\n        response.headers['Content-Disposition'] = 'attachment; filename=nodes.csv'\n        return response\n\n## Context 5: Markdown rendering\n\n    from markupsafe import Markup\n    import bleach\n    @app.route('/notes/')\n    def view_note(note_id):\n        """View note with safe markdown rendering"""\n        note = Note.query.get(note_id)\n\n## Sanitize markdown content (allow only safe HTML)\n\n        allowed_tags = ['p', 'br', 'strong', 'em', 'code', 'pre', 'blockquote', 'ul', 'ol', 'li']\n        allowed_attrs = {}\n\n## First: render markdown to HTML\n\n        import markdown\n        html_content = markdown.markdown(note.content)\n\n## Then: sanitize HTML\n\n        clean_html = bleach.clean(html_content, tags=allowed_tags, attributes=allowed_attrs)\n        return render_template('note.html', content=Markup(clean_html))\n\n## JSON API Response\n\n    @app.route('/api/nodes//logs')\n    def get_node_logs(node_id):\n        """Get node logs as JSON"""\n        logs = rpc_client.get_node_logs(node_id)\n\n## All data automatically escaped by jsonify\n\n        return jsonify({\n            'node_id': node_id,\n            'logs': [\n                {\n                    'timestamp': log.timestamp.isoformat(),\n                    'level': log.level,\n                    'message': log.message,  # Automatically escaped\n                }\n                for log in logs\n            ]\n        })\n\n## Common Vulnerabilities\n\n### XSS Examples\n\n### Vulnerability 1: Direct output without escaping\n\n## ? VULNERABLE\n\n    @app.route('/greeting/')\n    def greeting(name):\n        return f'Hello {name}'  # name not escaped\n\n## Attack: /greeting/alert('XSS')\n\n## Result: Hello alert('XSS')\n\n## Fix\n\n## ? SAFE\n\n    @app.route('/greeting/')\n    def greeting(name):\n        return render_template('greeting.html', name=name)\n\n## Or: return f'Hello {escape(name)}'\n\n## Vulnerability 2: User data in JavaScript\n\n## ? VULNERABLE [2]\n\n    {% raw %}\n      var username = "{{ username }}";  // Not escaped for JS context\n    {% endraw %}\n\n## Attack: username = "; alert('XSS'); var x = "\n\n## Result\n\n## var username = ""; alert('XSS'); var x = ""\n\n## Fix [2]\n\n## ? SAFE [2]\n\n    {% raw %}\n      var username = {{ username | tojson }};  // Properly escaped\n    {% endraw %}\n\n## Vulnerability 3: User data in HTML attribute\n\n     - ->\n\n### Vulnerability 4: User data in URL\n\n## ? VULNERABLE [3]\n\n    {% raw %}\n    Search\n    Search -->\n    {% endraw %}\n\n## ? SAFE [3]\n\n    {% raw %}\n    Search\n    {% endraw %}\n\n## SQL Injection Examples\n\n### Vulnerability: String concatenation in SQL\n\n## ? VULNERABLE [4]\n\n    @app.route('/nodes/')\n    def get_node(hostname):\n\n## BAD: Directly inserting user input into SQL\n\n        query = f"SELECT *FROM nodes WHERE hostname = '{hostname}'"\n        result = db.session.execute(query)\n        return result\n\n## Attack: hostname = "'; DROP TABLE nodes; --"\n\n## SQL: SELECT*FROM nodes WHERE hostname = ''; DROP TABLE nodes; --'\n\n## Fix: Parameterized queries\n\n## ? SAFE [4]\n\n    @app.route('/nodes/')\n    def get_node(hostname):\n\n## GOOD: Using parameterized queries (ORM)\n\n        result = Node.query.filter_by(hostname=hostname).first()\n        return result\n\n## Or with raw SQL\n\n## query = "SELECT* FROM nodes WHERE hostname = ?"\n\n## result = db.session.execute(query, (hostname,))\n\n## Command Injection Examples\n\n### Vulnerability: String concatenation in shell command\n\n## ? VULNERABLE [5]\n\n    import subprocess\n    @app.route('/api/nodes//ping')\n    def ping_node(node_id):\n\n## BAD: Shell command with user input\n\n        cmd = f"ping -c 4 {node_id}"\n        result = subprocess.run(cmd, shell=True, capture_output=True)\n        return result.stdout.decode()\n\n## Attack: node_id = "127.0.0.1; rm -rf /"\n\n## Shell: ping -c 4 127.0.0.1; rm -rf /\n\n## Fix: Avoid shell, use argument list\n\n## ? SAFE [5]\n\n    @app.route('/api/nodes//ping')\n    def ping_node(node_id):\n\n## Validate hostname first\n\n        hostname = Validators.validate_hostname(node_id)\n\n## Use argument list, no shell\n\n        result = subprocess.run(['ping', '-c', '4', hostname],\n                               capture_output=True, text=True, shell=False)\n        return result.stdout\n\n## Implementation Checklist\n\n### Input Validation\n\n- [] All user input validated (form, query params, API body)\n\n- [] Whitelist approach used (accept known-good input)\n\n- [] Type checking implemented\n\n- [] Format validation implemented (regex patterns)\n\n- [] Length limits enforced\n\n- [] Range limits enforced (numeric values)\n\n- [] Business logic validation implemented\n\n- [] Error messages don't leak information\n\n- [] Validation happens server-side (client-side is UI only)\n\n### Output Escaping\n\n- [] HTML content escaped in templates\n\n- [] HTML attributes properly escaped\n\n- [] JavaScript strings properly escaped (JSON.stringify)\n\n- [] URL parameters properly encoded\n\n- [] CSS values whitelisted/sanitized\n\n- [] No direct string concatenation for HTML\n\n- [] JSON responses use jsonify()\n\n- [] CSV/Excel export properly escaped\n\n### XSS Prevention\n\n- [] Jinja2 auto-escaping enabled\n\n- [] Content-Security-Policy header set\n\n- [] X-XSS-Protection header set\n\n- [] X-Content-Type-Options: nosniff set\n\n- [] No innerHTML usage in JavaScript\n\n- [] No eval() or similar dynamic code execution\n\n- [] Markdown sanitized with bleach\n\n- [] Event handlers validated\n\n### SQL Injection Prevention\n\n- [] No string concatenation in SQL queries\n\n- [] ORM (SQLAlchemy) used for queries\n\n- [] Parameterized queries for raw SQL\n\n- [] Input validated before database queries\n\n- [] Database user has minimal privileges\n\n- [] SQL errors don't expose schema\n\n### Command Injection Prevention\n\n- [] No string concatenation in shell commands\n\n- [] subprocess.run() with shell=False\n\n- [] Command arguments as list, not string\n\n- [] Input validated before command execution\n\n- [] Avoid shell=True completely\n\n### Third-party Libraries\n\n- [] Dependencies in requirements.txt\n\n- [] Versions pinned (no wildcards)\n\n- [] Regular pip-audit for vulnerabilities\n\n- [] Security patches applied promptly\n\n- [ ] Deprecated libraries replaced\n\n- --\n\n### Testing Commands\n\n## Find SQL injection risks\n\n    grep -r "\.execute\|\.query\|f\".*SELECT\|f'.*SELECT" --include="*.py" .\n\n## Find potential XSS risks\n\n    grep -r "Markup(\|unsafe=\|render_template_string" --include="*.py" .\n\n## Find command injection risks\n\n    grep -r "shell=True\|os.system\|exec(" --include="*.py" .\n\n## Check dependencies for vulnerabilities\n\n    pip install pip-audit\n    pip-audit\n\n## Run security scan\n\n    pip install bandit\n    bandit -r . -ll\n\n
