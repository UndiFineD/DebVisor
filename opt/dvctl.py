#!/usr/bin/env python3
# Copyright (c) 2025 DebVisor contributors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python3
# Copyright (c) 2025 DebVisor contributors
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
dvctl - DebVisor Unified Control Plane CLI

This tool unifies the management of the OS, Kubernetes, Storage (Ceph/ZFS),
and Virtualization (KVM) into a single interface, rivaling 'talosctl'.
"""

    # import argparse
    # import sys
    # import loggingimport subprocess
import argparse
import logging
import subprocess
import sys
import json
import hashlib
import os
from typing import Dict

# Import existing enhanced modules (simulated import for structure)
try:
    from opt.system.upgrade_manager import UpgradeManager
    from opt.core.logging import configure_logging
except ImportError:
    # Fallback for standalone testing if modules aren't in pythonpath
    def configure_logging(service_name="dvctl"):  # type: ignore[misc]
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - DVCTL - %(levelname)s - %(message)s",
        )


configure_logging(service_name="dvctl")
logger = logging.getLogger(__name__)


class DriftDetector:
    """
    Detects configuration drift by comparing current file hashes against a known good state.
    In a real deployment, this 'known good state' would be generated by the build pipeline.
    """

    CRITICAL_FILES = [
        "/etc/ssh/sshd_config",
        "/etc/kubernetes/admin.conf",
        "/etc/ceph/ceph.conf",
        "/etc/hosts",
        "/etc/resolv.conf",
    ]

    def __init__(self, manifest_path: str = "/etc/debvisor/manifest.json"):
        self.manifest_path = manifest_path
        self.manifest = self._load_manifest()

    def _load_manifest(self) -> Dict[str, str]:
        if os.path.exists(self.manifest_path):
            try:
                with open(self.manifest_path, "r") as f:
                    return json.load(f)
            except json.JSONDecodeError:
                logger.warning(f"Corrupt manifest at {self.manifest_path}")
                return {}
        return {}

    def generate_manifest(self) -> None:
        """Generate a manifest from the current state (Golden Image creation)."""
        manifest = {}
        for filepath in self.CRITICAL_FILES:
            if os.path.exists(filepath):
                manifest[filepath] = self._calculate_hash(filepath)

        os.makedirs(os.path.dirname(self.manifest_path), exist_ok=True)
        with open(self.manifest_path, "w") as f:
            json.dump(manifest, f, indent=2)
        logger.info(f"Generated drift manifest at {self.manifest_path}")

    def check(self) -> bool:
        """Check for drift. Returns True if drift is detected."""
        drift_found = False
        if not self.manifest:
            logger.warning("No manifest found. Cannot check for drift.")
            return False

        for filepath, expected_hash in self.manifest.items():
            if not os.path.exists(filepath):
                logger.error(f"MISSING: {filepath}")
                drift_found = True
                continue

            current_hash = self._calculate_hash(filepath)
            if current_hash != expected_hash:
                logger.error(f"DRIFT: {filepath} (Hash mismatch)")
                drift_found = True

        return drift_found

    def _calculate_hash(self, filepath: str) -> str:
        sha256_hash = hashlib.sha256()
        try:
            with open(filepath, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except PermissionError:
            return "PERMISSION_DENIED"


class DebVisorController:
    def __init__(self) -> None:
        self.version = "0.1.0-alpha"
        self.drift_detector = DriftDetector()

    def status(self, component: str = "all") -> None:
        """Get status of the entire stack."""
        status_report = {"timestamp": "now", "components": {}}

        if component in ["all", "k8s"]:
            status_report["components"]["kubernetes"] = self._check_service("kubelet")  # type: ignore[index]

        if component in ["all", "storage"]:
            status_report["components"]["storage"] = self._check_service("ceph.target")  # type: ignore[index]

        if component in ["all", "vm"]:
            status_report["components"]["virtualization"] = self._check_service(  # type: ignore[index]
                "libvirtd"
            )

        print(json.dumps(status_report, indent=2))

    def _check_service(self, service_name: str) -> str:
        """Check systemd service status."""
        try:
            subprocess.check_call(["systemctl", "is-active", "--quiet", service_name])
            return "Active"
        except (subprocess.CalledProcessError, FileNotFoundError):
            return "Inactive/Missing"

    def drift_check(self, generate: bool = False) -> None:
        """Check for configuration drift (Immutability check)."""
        if generate:
            self.drift_detector.generate_manifest()
            return

        logger.info("Running configuration drift detection...")
        if self.drift_detector.check():
            logger.error("DRIFT DETECTED: System state does not match manifest!")
            sys.exit(1)
        else:
            logger.info("System is compliant with defined state.")

    def upgrade(self, image_path: str) -> None:
        """Perform an atomic OS upgrade using A/B partitions."""
        try:
            mgr = UpgradeManager()
            status = mgr.get_status()
            logger.info(
                f"Current Status: Active={status['active_slot']}, Target={status['inactive_slot']}"
            )

            mgr.install_image(image_path)
            mgr.switch_boot_slot()
            logger.info("Upgrade successful. Please reboot to apply changes.")
        except Exception as e:
            logger.error(f"Upgrade failed: {e}")
            sys.exit(1)

    def tui(self) -> None:
        """Launch the Text User Interface."""
        tui_path = os.path.join(os.path.dirname(__file__), "netcfg_tui_app.py")
        if os.path.exists(tui_path):
            logger.info("Launching TUI...")
            try:
                subprocess.run([sys.executable, tui_path])
            except KeyboardInterrupt:
                pass
        else:
            logger.error(f"TUI application not found at {tui_path}")

    def harden(self) -> None:
        """Apply security hardening."""
        script_path = os.path.join(
            os.path.dirname(__file__), "security", "ssh_hardener.py"
        )
        if os.path.exists(script_path):
            logger.info("Applying SSH hardening...")
            subprocess.run([sys.executable, script_path])
        else:
            logger.error(f"Hardening script not found at {script_path}")

    def discover(self, timeout: int = 5) -> None:
        """Scan for other nodes."""
        script_path = os.path.join(
            os.path.dirname(__file__), "discovery", "zerotouch.py"
        )
        if os.path.exists(script_path):
            subprocess.run(
                [sys.executable, script_path, "scan", "--timeout", str(timeout)]
            )
        else:
            logger.error(f"Discovery script not found at {script_path}")

    def advertise(self, role: str = "worker") -> None:
        """Advertise this node."""
        script_path = os.path.join(
            os.path.dirname(__file__), "discovery", "zerotouch.py"
        )
        if os.path.exists(script_path):
            subprocess.run([sys.executable, script_path, "advertise", "--role", role])
        else:
            logger.error(f"Discovery script not found at {script_path}")


def main() -> None:
    parser = argparse.ArgumentParser(description="DebVisor Unified Control Plane")
    parser.add_argument("--version", action="version", version="0.1.0")

    subparsers = parser.add_subparsers(dest="command", help="Sub-command help")

    # Status Command
    status_parser = subparsers.add_parser("status", help="Show system status")
    status_parser.add_argument(
        "--component", choices=["all", "k8s", "storage", "vm"], default="all"
    )

    # Drift Command
    drift_parser = subparsers.add_parser("drift", help="Check for configuration drift")
    drift_parser.add_argument(
        "--generate",
        action="store_true",
        help="Generate golden manifest from current state",
    )

    # Upgrade Command
    upgrade_parser = subparsers.add_parser("upgrade", help="Upgrade DebVisor OS")
    upgrade_parser.add_argument("version", help="Target version")

    # TUI Command
    subparsers.add_parser("tui", help="Launch Interactive TUI")

    # Hardening Command
    subparsers.add_parser("harden", help="Apply security hardening (SSH)")

    # Discovery Commands
    discover_parser = subparsers.add_parser("discover", help="Scan for other nodes")
    discover_parser.add_argument("--timeout", type=int, default=5, help="Scan duration")

    advertise_parser = subparsers.add_parser("advertise", help="Advertise this node")
    advertise_parser.add_argument("--role", default="worker", help="Node role")

    # K8s Passthrough
    k8s_parser = subparsers.add_parser("k8s", help="Kubernetes operations")
    k8s_parser.add_argument("action", help="Action to perform")

    # Storage Passthrough
    storage_parser = subparsers.add_parser("storage", help="Storage operations")
    storage_parser.add_argument("action", help="Action to perform")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    ctl = DebVisorController()

    if args.command == "status":
        ctl.status(args.component)
    elif args.command == "drift":
        ctl.drift_check(args.generate)
    elif args.command == "upgrade":
        ctl.upgrade(args.version)
    elif args.command == "tui":
        ctl.tui()
    elif args.command == "harden":
        ctl.harden()
    elif args.command == "discover":
        ctl.discover(args.timeout)
    elif args.command == "advertise":
        ctl.advertise(args.role)
    elif args.command == "k8s":
        # Proxy to k8sctl
        logger.info(f"Proxying to k8sctl: {args.action}")
    elif args.command == "storage":
        # Proxy to cephctl
        logger.info(f"Proxying to cephctl: {args.action}")
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
